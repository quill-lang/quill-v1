use serde::{Deserialize, Serialize};
use std::{
    fmt::{Debug, Display},
    path::PathBuf,
};

#[derive(Clone, Copy, Serialize, Deserialize)]
pub struct TargetTriple {
    pub arch: TargetArchitecture,
    pub vendor: TargetVendor,
    pub os: TargetOS,
    pub env: Option<TargetEnvironment>,
}

impl TargetTriple {
    pub fn to_zig_target(self) -> &'static str {
        match (self.arch, self.vendor, self.os) {
            (TargetArchitecture::X86_64, TargetVendor::Unknown, TargetOS::Linux) => {
                "x86_64-linux-gnu"
            }
            (TargetArchitecture::X86_64, TargetVendor::Pc, TargetOS::Windows) => {
                "x86_64-windows-gnu"
            }
            _ => {
                panic!("unsupported target")
            }
        }
    }

    /// On Windows, returns `x86_64-pc-windows-gnu`.
    #[cfg(target_family = "windows")]
    pub fn default_triple() -> TargetTriple {
        TargetTriple {
            arch: TargetArchitecture::X86_64,
            vendor: TargetVendor::Pc,
            os: TargetOS::Windows,
            env: Some(TargetEnvironment::Gnu),
        }
    }

    /// On Unix, returns `x86_64-unknown-linux-gnu`.
    #[cfg(target_family = "unix")]
    pub fn default_triple() -> TargetTriple {
        TargetTriple {
            arch: TargetArchitecture::X86_64,
            vendor: TargetVendor::Unknown,
            os: TargetOS::Linux,
            env: Some(TargetEnvironment::Gnu),
        }
    }
}

impl Display for TargetTriple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(env) = &self.env {
            write!(f, "{}-{}-{}-{}", self.arch, self.vendor, self.os, env)
        } else {
            write!(f, "{}-{}-{}", self.arch, self.vendor, self.os)
        }
    }
}

impl Debug for TargetTriple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        Display::fmt(&self, f)
    }
}

#[derive(Clone, Copy, Serialize, Deserialize)]
pub enum TargetArchitecture {
    X86_64,
}

impl Display for TargetArchitecture {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                TargetArchitecture::X86_64 => "x86_64",
            }
        )
    }
}

#[derive(Clone, Copy, Serialize, Deserialize)]
pub enum TargetVendor {
    Unknown,
    Pc,
}

impl Display for TargetVendor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                TargetVendor::Unknown => "unknown",
                TargetVendor::Pc => "pc",
            }
        )
    }
}

#[derive(Clone, Copy, Serialize, Deserialize)]
pub enum TargetOS {
    Linux,
    Windows,
}

impl Display for TargetOS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                TargetOS::Linux => "linux",
                TargetOS::Windows => "windows",
            }
        )
    }
}

#[derive(Clone, Copy, Serialize, Deserialize)]
pub enum TargetEnvironment {
    Gnu,
}

impl Display for TargetEnvironment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                TargetEnvironment::Gnu => "gnu",
            }
        )
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BuildInfo {
    pub target_triple: TargetTriple,
    pub code_folder: PathBuf,
    pub build_folder: PathBuf,
}

impl BuildInfo {
    /// Gives the path of the executable generated by the given build.
    pub fn executable(&self, project_name: &str) -> PathBuf {
        match self.target_triple.os {
            TargetOS::Linux => self.build_folder.join(project_name),
            TargetOS::Windows => self.build_folder.join(format!("{}.exe", project_name)),
        }
    }
}
