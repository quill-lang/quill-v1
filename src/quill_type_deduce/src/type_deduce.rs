use std::collections::{hash_map::Entry, HashMap, VecDeque};

use quill_common::{
    diagnostic::{Diagnostic, DiagnosticResult, ErrorMessage, HelpMessage, HelpType, Severity},
    location::{Range, Ranged, SourceFileIdentifier},
    name::QualifiedName,
};
use quill_index::{ProjectIndex, TypeDeclarationTypeI};
use quill_parser::{ConstantValue, ExprPatP, IdentifierP, NameP};
use quill_type::{PrimitiveType, Type};

use crate::{
    index_resolve::{
        as_variable, instantiate, instantiate_with, resolve_definition, resolve_type_constructor,
        InstantiationResult,
    },
    type_check::{
        AbstractionVariable, BoundVariable, Expression, ExpressionContents, ExpressionContentsT,
        ExpressionT, TypeVariable, TypeVariablePrinter, VisibleNames,
    },
    type_resolve::TypeVariableId,
};

/// An intermediate result after having documented an expression's types.
#[derive(Debug)]
struct ExprTypeCheck {
    expr: ExpressionT,
    /// When we create a new type variable, we should store its location of definition in this map.
    type_variable_definition_ranges: HashMap<TypeVariableId, Range>,
    assumptions: Assumptions,
    constraints: Constraints,
    /// The list of variables defined in `let` statements in scope.
    /// When `generate_constraints` is called, typically the `let_variables` map is simply moved into this field here.
    /// However, if we were generating constraints for a let statement, the let variables list will have this new variable added to it.
    let_variables: HashMap<String, AbstractionVariable>,
    /// If this expression was a `let` statement, this will contain a list of all the new variables we defined in this statement,
    new_variables: Option<LetStatementNewVariables>,
}

#[derive(Debug)]
struct LetStatementNewVariables {
    let_token: Range,
    /// A list of the new variables we made, with the type variable we assigned to it.
    new_variables: Vec<(NameP, TypeVariableId)>,
}

/// A list of assumptions about each variable's type.
/// Assumptions are applied only to the current list of monomorphic and polymorphic variables,
/// i.e. exactly the list of variables introduced by lambda and let statements respectively.
#[derive(Debug, Default)]
struct Assumptions(HashMap<NameP, Vec<Assumption>>);

impl Assumptions {
    fn new_with(var: NameP, assumption: Assumption) -> Self {
        let mut map = HashMap::new();
        map.insert(var, vec![assumption]);
        Self(map)
    }

    fn union(mut self, other: Self) -> Self {
        for (ty, mut assumptions) in other.0 {
            match self.0.entry(ty) {
                Entry::Occupied(mut occupied) => occupied.get_mut().append(&mut assumptions),
                Entry::Vacant(vacant) => {
                    vacant.insert(assumptions);
                }
            }
        }
        self
    }
}

/// An assumption records the type variables assigned to a given local variable,
/// such as those local variables generated by `lambda` and `let` statements.
#[derive(Debug)]
struct Assumption(TypeVariableId);

/// A list of constraints between types.
#[derive(Debug, Default)]
struct Constraints(Vec<(TypeVariable, Constraint)>);

impl Constraints {
    fn new_with(ty: TypeVariable, constraint: Constraint) -> Self {
        Self(vec![(ty, constraint)])
    }

    fn union(mut self, mut other: Self) -> Self {
        self.0.append(&mut other.0);
        self
    }
}

/// A constraint about a variable's type, used by the type checker.
#[derive(Debug)]
enum Constraint {
    /// The given type is exactly equal to this type.
    Equality {
        ty: TypeVariable,
        reason: ConstraintEqualityReason,
    },
}

#[derive(Debug)]
enum ConstraintEqualityReason {
    /// This constraint was generated as a result of applying a function to a variable.
    Apply {
        /// The function we're invoking.
        function_range: Range,
        function_ty: TypeVariable,
        /// The argument we're supplying.
        argument_range: Range,
        argument_ty: TypeVariable,
    },
    /// This constraint was generated as a result of generating a lambda abstraction's type.
    /// These constraints should probably be solved first if possible, since they're likely
    /// to have really bad error messages.
    LambdaType { lambda: Range },
    /// This constraint was generated as a result of a lambda's parameter being used
    /// in the lambda expression body.
    LambdaParameter {
        lambda: Range,
        param_name: String,
        param_range: Range,
    },
    /// This constraint was generated as a result of specifying that a let expression's
    /// type must be equal to the right hand expression's type.
    LetType { let_token: Range, expression: Range },
    /// The expression was defined to be a specific type.
    ByDefinition {
        /// The expression we're type checking.
        expr: Range,
        /// The definition that shows what type it must have.
        definition: Range,
    },
    /// The expression was used as a field in a data constructor, and we know the type of the field.
    Field {
        /// The expression we're type checking.
        expr: Range,
        /// The data type we're constructing.
        data_type: QualifiedName,
        /// The type constructor.
        type_ctor: String,
        /// The field name.
        field: String,
    },
    /// This expression is an instance of the variable bound in a let expression.
    InstanceLet {
        /// The name of the variable.
        variable_name: String,
        /// The variable's type.
        variable_type: TypeVariable,
        /// The expression we're type checking.
        expr: Range,
        /// The token `let` that we're using the variable from.
        let_token: Range,
    },
    /// A variable was borrowed.
    Borrow { expr: Range, borrow_token: Range },
    /// A variable was copied.
    Copy { expr: Range, copy_token: Range },
}

pub fn deduce_expr_type(
    source_file: &SourceFileIdentifier,
    project_index: &ProjectIndex,
    visible_names: &VisibleNames,
    args: &HashMap<String, BoundVariable>,
    expr: ExprPatP,
    expected_type: Type,
    definition_identifier_range: Range,
) -> DiagnosticResult<Expression> {
    generate_constraints(
        source_file,
        project_index,
        visible_names,
        args,
        HashMap::new(),
        HashMap::new(),
        expr,
    )
    .deny()
    .bind(|mut expr_type_check| {
        if !expr_type_check.assumptions.0.is_empty() {
            panic!("unresolved assumptions {:#?}", expr_type_check.assumptions);
        }
        expr_type_check.constraints.0.push((
            expr_type_check.expr.type_variable.clone(),
            Constraint::Equality {
                ty: as_variable(&expected_type),
                reason: ConstraintEqualityReason::ByDefinition {
                    expr: expr_type_check.expr.range(),
                    definition: definition_identifier_range,
                },
            },
        ));
        solve_type_constraints(
            source_file,
            project_index,
            expr_type_check.expr,
            expr_type_check.constraints,
        )
    })
}

/// Assigns new type variables to each sub-expression, so that this expression can be easily type checked.
/// This uses the algorithm from <https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.9348> to assign constraints to these type variables.
///
/// Assumptions and constraints will be generated by each sub-expression.
/// `lambda_variables` is the set of variables that we introduced using a lambda expression. Assumptions in the returned value only relate to this
/// set of lambda variables.
/// `let_variables` is the set of variables that we introduced using a let expression.
fn generate_constraints(
    source_file: &SourceFileIdentifier,
    project_index: &ProjectIndex,
    visible_names: &VisibleNames,
    args: &HashMap<String, BoundVariable>,
    mut lambda_variables: HashMap<String, AbstractionVariable>,
    mut let_variables: HashMap<String, AbstractionVariable>,
    expr: ExprPatP,
) -> DiagnosticResult<ExprTypeCheck> {
    match expr {
        ExprPatP::Variable(identifier) => {
            // Let's try to work out what this identifier is referring to.
            if identifier.segments.len() == 1 {
                let name = identifier.segments[0].clone();
                // First, check the function's arguments.
                if let Some(arg) = args.get(&name.name) {
                    // We don't need to add an assumption or constraint about this type variable, since it is known.
                    return DiagnosticResult::ok(ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable: as_variable(&arg.var_type),
                            contents: ExpressionContentsT::Argument(name),
                        },
                        type_variable_definition_ranges: HashMap::new(),
                        assumptions: Assumptions::default(),
                        constraints: Constraints::default(),
                        let_variables,
                        new_variables: None,
                    });
                }

                // Now, check the lambda variables.
                if lambda_variables.get(&name.name).is_some() {
                    let type_variable = TypeVariableId::default();
                    let identifier_name = name.clone();
                    let mut type_variable_definition_ranges = HashMap::new();
                    type_variable_definition_ranges.insert(type_variable, name.range);
                    return DiagnosticResult::ok(ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable: TypeVariable::Unknown { id: type_variable },
                            contents: ExpressionContentsT::Local(name),
                        },
                        type_variable_definition_ranges,
                        assumptions: Assumptions::new_with(
                            identifier_name,
                            Assumption(type_variable),
                        ),
                        constraints: Constraints::default(),
                        let_variables,
                        new_variables: None,
                    });
                }
                // Now, check the let variables.
                if let_variables.get(&name.name).is_some() {
                    let type_variable = TypeVariableId::default();
                    let identifier_name = name.clone();
                    let mut type_variable_definition_ranges = HashMap::new();
                    type_variable_definition_ranges.insert(type_variable, name.range);
                    return DiagnosticResult::ok(ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable: TypeVariable::Unknown { id: type_variable },
                            contents: ExpressionContentsT::Local(name),
                        },
                        type_variable_definition_ranges,
                        assumptions: Assumptions::new_with(
                            identifier_name,
                            Assumption(type_variable),
                        ),
                        constraints: Constraints::default(),
                        let_variables,
                        new_variables: None,
                    });
                }
            }

            // Now let's look for a symbol in scope.
            match resolve_definition(source_file, &identifier, visible_names)
                .destructure()
                .0
            {
                Some((symbol_source_file, symbol)) => {
                    // We don't need an assumption, we know what the type of this symbol is.
                    let InstantiationResult {
                        result: type_variable,
                        ids: type_variables,
                        ..
                    } = instantiate(&symbol.symbol_type);
                    DiagnosticResult::ok(ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable,
                            contents: ExpressionContentsT::Symbol {
                                name: QualifiedName {
                                    source_file: symbol_source_file.clone(),
                                    name: symbol.name.name.clone(),
                                    range: symbol.name.range,
                                },
                                range: identifier.range(),
                                type_variables,
                            },
                        },
                        type_variable_definition_ranges: HashMap::new(),
                        assumptions: Assumptions::default(),
                        constraints: Constraints::default(),
                        let_variables,
                        new_variables: None,
                    })
                }
                // If None, we couldn't find a symbol in scope.
                None => {
                    // Now, check to see if this is an immediate variable like `unit`, which always produces a value.

                    DiagnosticResult::fail(ErrorMessage::new(
                        format!("variable `{}` not recognised", identifier),
                        Severity::Error,
                        Diagnostic::at(source_file, &identifier),
                    ))
                }
            }
        }
        ExprPatP::Immediate {
            range,
            value: ConstantValue::Unit,
        } => DiagnosticResult::ok(ExprTypeCheck {
            expr: ExpressionT {
                type_variable: TypeVariable::Primitive(PrimitiveType::Unit),
                contents: ExpressionContentsT::ConstantValue {
                    range,
                    value: ConstantValue::Unit,
                },
            },
            type_variable_definition_ranges: HashMap::new(),
            assumptions: Assumptions::default(),
            constraints: Constraints::default(),
            let_variables,
            new_variables: None,
        }),
        ExprPatP::Immediate {
            range,
            value: ConstantValue::Bool(value),
        } => DiagnosticResult::ok(ExprTypeCheck {
            expr: ExpressionT {
                type_variable: TypeVariable::Primitive(PrimitiveType::Bool),
                contents: ExpressionContentsT::ConstantValue {
                    range,
                    value: ConstantValue::Bool(value),
                },
            },
            type_variable_definition_ranges: HashMap::new(),
            assumptions: Assumptions::default(),
            constraints: Constraints::default(),
            let_variables,
            new_variables: None,
        }),
        ExprPatP::Immediate {
            range,
            value: ConstantValue::Int(value),
        } => DiagnosticResult::ok(ExprTypeCheck {
            expr: ExpressionT {
                type_variable: TypeVariable::Primitive(PrimitiveType::Int),
                contents: ExpressionContentsT::ConstantValue {
                    range,
                    value: ConstantValue::Int(value),
                },
            },
            type_variable_definition_ranges: HashMap::new(),
            assumptions: Assumptions::default(),
            constraints: Constraints::default(),
            let_variables,
            new_variables: None,
        }),
        ExprPatP::Apply(left, right) => {
            generate_constraints(
                source_file,
                project_index,
                visible_names,
                args,
                lambda_variables.clone(),
                let_variables.clone(),
                *left,
            )
            .bind(|left| {
                generate_constraints(
                    source_file,
                    project_index,
                    visible_names,
                    args,
                    lambda_variables,
                    let_variables.clone(),
                    *right,
                )
                .map(|right| {
                    let left_type = left.expr.type_variable.clone();
                    let right_type = right.expr.type_variable.clone();
                    let result_type = TypeVariable::Unknown {
                        id: TypeVariableId::default(),
                    };

                    let function_range = left.expr.contents.range();
                    let argument_range = right.expr.contents.range();
                    let function_ty = left.expr.type_variable.clone();
                    let argument_ty = right.expr.type_variable.clone();

                    // This expression was: left_type right_type : result_type
                    // Constraint: left_type === right_type -> result_type
                    let mut type_variable_definition_ranges = HashMap::new();
                    type_variable_definition_ranges.extend(left.type_variable_definition_ranges);
                    type_variable_definition_ranges.extend(right.type_variable_definition_ranges);
                    ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable: result_type.clone(),
                            contents: ExpressionContentsT::Apply(
                                Box::new(left.expr),
                                Box::new(right.expr),
                            ),
                        },
                        type_variable_definition_ranges,
                        assumptions: left.assumptions.union(right.assumptions),
                        constraints: left.constraints.union(right.constraints).union(
                            Constraints::new_with(
                                left_type,
                                Constraint::Equality {
                                    ty: TypeVariable::Function(
                                        Box::new(right_type),
                                        Box::new(result_type),
                                    ),
                                    reason: ConstraintEqualityReason::Apply {
                                        function_range,
                                        argument_range,
                                        function_ty,
                                        argument_ty,
                                    },
                                },
                            ),
                        ),
                        let_variables,
                        new_variables: None,
                    }
                })
            })
        }
        ExprPatP::Unknown(range) => DiagnosticResult::fail(ErrorMessage::new(
            String::from("underscore not allowed in expressions"),
            Severity::Error,
            Diagnostic::at(source_file, &range),
        )),
        ExprPatP::Lambda {
            lambda_token,
            params,
            expr,
        } => {
            // This introduces new lambda variables, so we'll need to edit the `lambda_variables` map.
            let mut messages = Vec::new();
            let mut param_types = Vec::new();
            let mut type_variable_definition_ranges = HashMap::new();

            for param in &params {
                let NameP { name, range } = param;
                match lambda_variables.entry(name.clone()) {
                    Entry::Occupied(occupied) => {
                        messages.push(already_defined(source_file, *range, occupied.get().range));
                    }
                    Entry::Vacant(vacant) => {
                        if let Some(previous) = args.get(name) {
                            messages.push(already_defined(source_file, *range, previous.range));
                        }
                        if let Some(previous) = let_variables.get(name) {
                            messages.push(already_defined(source_file, *range, previous.range));
                        }
                        let param_type = TypeVariableId::default();
                        param_types.push(param_type);
                        vacant.insert(AbstractionVariable {
                            range: *range,
                            var_type: param_type,
                        });
                        type_variable_definition_ranges.insert(param_type, *range);
                    }
                }
            }

            DiagnosticResult::ok_with_many(lambda_variables, messages)
                .deny()
                .bind(|lambda_variables| {
                    generate_constraints(
                        source_file,
                        project_index,
                        visible_names,
                        args,
                        lambda_variables,
                        let_variables.clone(),
                        *expr,
                    )
                    .map(|mut expr| {
                        // First, add the constraint that this lambda abstraction's type is input_types -> expr.type.
                        // Gradually process the params to this function, curring each at a time, to get a resultant type variable.
                        let mut lambda_type = expr.expr.type_variable.clone();
                        for param in param_types.iter().rev() {
                            let lambda_step_type = TypeVariable::Unknown {
                                id: TypeVariableId::default(),
                            };
                            expr.constraints.0.push((
                                lambda_step_type.clone(),
                                Constraint::Equality {
                                    ty: TypeVariable::Function(
                                        Box::new(TypeVariable::Unknown { id: *param }),
                                        Box::new(lambda_type),
                                    ),
                                    reason: ConstraintEqualityReason::LambdaType {
                                        lambda: lambda_token,
                                    },
                                },
                            ));
                            lambda_type = lambda_step_type;
                        }

                        // Let's now remove and process the assumptions about the parameters.
                        // This expression was: lambda params -> expr : (input_types -> expr.type)
                        // Constraints: ts === input_types, for all assumptions that params : ts
                        let mut new_constraints = Vec::new();
                        for ((param, assumptions), param_type) in params
                            .iter()
                            .map(|param| {
                                (param, expr.assumptions.0.remove(&param).unwrap_or_default())
                            })
                            .zip(param_types)
                        {
                            for assumption in assumptions {
                                new_constraints.push((
                                    TypeVariable::Unknown { id: param_type },
                                    Constraint::Equality {
                                        ty: TypeVariable::Unknown { id: assumption.0 },
                                        reason: ConstraintEqualityReason::LambdaParameter {
                                            lambda: lambda_token,
                                            param_name: param.name.clone(),
                                            param_range: param.range,
                                        },
                                    },
                                ));
                            }
                        }
                        expr.constraints.0.extend(new_constraints);

                        type_variable_definition_ranges
                            .extend(expr.type_variable_definition_ranges);

                        ExprTypeCheck {
                            expr: ExpressionT {
                                type_variable: lambda_type,
                                contents: ExpressionContentsT::Lambda {
                                    lambda_token,
                                    params,
                                    expr: Box::new(expr.expr),
                                },
                            },
                            type_variable_definition_ranges,
                            assumptions: expr.assumptions,
                            constraints: expr.constraints,
                            let_variables,
                            new_variables: None,
                        }
                    })
                })
        }
        ExprPatP::Let {
            let_token,
            name,
            expr,
        } => {
            generate_constraints(
                source_file,
                project_index,
                visible_names,
                args,
                lambda_variables.clone(),
                let_variables.clone(),
                *expr,
            )
            .bind(|expr| {
                // This introduces new let variables, so we'll need to edit the `let_variables` map.
                let mut messages = Vec::new();
                let new_variable_type = TypeVariableId::default();
                let mut type_variable_definition_ranges = HashMap::new();

                let NameP { name, range } = &name;
                match let_variables.entry(name.clone()) {
                    Entry::Occupied(occupied) => {
                        messages.push(already_defined(source_file, *range, occupied.get().range));
                    }
                    Entry::Vacant(vacant) => {
                        if let Some(previous) = args.get(name) {
                            messages.push(already_defined(source_file, *range, previous.range));
                        }
                        if let Some(previous) = lambda_variables.get(name) {
                            messages.push(already_defined(source_file, *range, previous.range));
                        }
                        vacant.insert(AbstractionVariable {
                            range: *range,
                            var_type: new_variable_type,
                        });
                        type_variable_definition_ranges.insert(new_variable_type, *range);
                    }
                }

                let name = NameP {
                    name: name.clone(),
                    range: *range,
                };

                let mut constraints = expr.constraints;
                constraints.0.push((
                    TypeVariable::Unknown {
                        id: new_variable_type,
                    },
                    Constraint::Equality {
                        ty: expr.expr.type_variable.clone(),
                        reason: ConstraintEqualityReason::LetType {
                            let_token,
                            expression: expr.expr.range(),
                        },
                    },
                ));

                DiagnosticResult::ok_with_many(
                    ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable: TypeVariable::Primitive(PrimitiveType::Unit),
                            contents: ExpressionContentsT::Let {
                                let_token,
                                name: name.clone(),
                                expr: Box::new(expr.expr),
                            },
                        },
                        type_variable_definition_ranges,
                        assumptions: expr.assumptions,
                        constraints,
                        let_variables,
                        new_variables: Some(LetStatementNewVariables {
                            let_token,
                            new_variables: vec![(name, new_variable_type)],
                        }),
                    },
                    messages,
                )
            })
        }
        ExprPatP::Block {
            open_bracket,
            close_bracket,
            statements,
        } => {
            // Generate constraints for every statement in the block.
            let mut statements_with_constraints = Vec::new();
            let mut messages = Vec::new();
            let mut let_variables = let_variables;
            let mut type_variable_definition_ranges = HashMap::new();
            let mut assumptions = Assumptions::default();
            let mut constraints = Constraints::default();
            // The list of new variables is updated whenever we introduce a `let` statement in this block.
            let mut new_variables = Vec::<LetStatementNewVariables>::new();
            // println!("Statements: {:#?}", statements);
            for statement in statements {
                let (result, inner_messages) = generate_constraints(
                    source_file,
                    project_index,
                    visible_names,
                    args,
                    lambda_variables.clone(),
                    let_variables.clone(),
                    statement,
                )
                .destructure();
                messages.extend(inner_messages);
                if let Some(mut result) = result {
                    constraints = constraints.union(result.constraints);

                    for some_new_variables in &new_variables {
                        for (variable_name, variable_type_var_id) in
                            &some_new_variables.new_variables
                        {
                            // First, let's remove and store the assumptions about the variables that we created in previous let statements.
                            let let_assumptions = result
                                .assumptions
                                .0
                                .remove(&variable_name)
                                .unwrap_or_else(Vec::new);

                            for assumption in let_assumptions {
                                constraints.0.push((
                                    TypeVariable::Unknown { id: assumption.0 },
                                    Constraint::Equality {
                                        ty: TypeVariable::Unknown {
                                            id: *variable_type_var_id,
                                        },
                                        reason: ConstraintEqualityReason::InstanceLet {
                                            let_token: some_new_variables.let_token,
                                            expr: result.expr.range(),
                                            variable_name: variable_name.name.to_string(),
                                            variable_type: TypeVariable::Unknown {
                                                id: *variable_type_var_id,
                                            },
                                        },
                                    },
                                ));
                            }
                        }
                    }

                    let_variables = result.let_variables;
                    type_variable_definition_ranges.extend(result.type_variable_definition_ranges);
                    assumptions = assumptions.union(result.assumptions);
                    statements_with_constraints.push(result.expr);

                    if let Some(more_new_variables) = result.new_variables {
                        new_variables.push(more_new_variables);
                    }
                }
            }

            if statements_with_constraints.is_empty() {
                // We can't deduce the block's type so we have to fail early.
                return DiagnosticResult::fail_many(messages);
            }

            // Work out what the type of the block is. Typically, this is just the type of the last statement in the block,
            // unless a final semicolon was added.
            let block_type = statements_with_constraints[statements_with_constraints.len() - 1]
                .type_variable
                .clone();

            DiagnosticResult::ok_with_many(
                ExprTypeCheck {
                    expr: ExpressionT {
                        type_variable: block_type,
                        contents: ExpressionContentsT::Block {
                            open_bracket,
                            close_bracket,
                            statements: statements_with_constraints,
                        },
                    },
                    type_variable_definition_ranges,
                    assumptions,
                    constraints,
                    let_variables,
                    new_variables: None,
                },
                messages,
            )
        }
        ExprPatP::ConstructData {
            data_constructor,
            fields,
            open_brace,
            close_brace,
        } => {
            // Resolve the type constructor that was invoked.
            resolve_type_constructor(source_file, &data_constructor, visible_names).bind(
                |type_constructor_invocation| {
                    // Generate a type variable for this data type.
                    let type_parameter_variables = (0..type_constructor_invocation.num_parameters)
                        .map(|_| TypeVariableId::default())
                        .collect::<Vec<_>>();
                    let type_variable = TypeVariable::Named {
                        name: type_constructor_invocation.data_type.clone(),
                        parameters: type_parameter_variables
                            .iter()
                            .map(|id| TypeVariable::Unknown { id: *id })
                            .collect(),
                    };

                    // Find the type constructor.
                    let (type_ctor, type_params) = match &visible_names.types
                        [type_constructor_invocation.data_type.name.as_str()]
                    .decl
                    .decl_type
                    {
                        TypeDeclarationTypeI::Data(datai) => (&datai.type_ctor, &datai.type_params),
                        TypeDeclarationTypeI::Enum(enumi) => (
                            &enumi
                                .variants
                                .iter()
                                .find(|variant| {
                                    &variant.name.name
                                        == type_constructor_invocation.variant.as_ref().unwrap()
                                })
                                .unwrap()
                                .type_ctor,
                            &enumi.type_params,
                        ),
                    };

                    // Generate constraints for each field.
                    let mut fields_with_constraints = Vec::new();
                    let mut messages = Vec::new();
                    let mut type_variable_definition_ranges = HashMap::new();
                    let mut assumptions = Assumptions::default();
                    let mut constraints = Constraints::default();

                    let mut ids = HashMap::new();
                    for (i, type_param) in type_params.iter().enumerate() {
                        ids.insert(
                            type_param.name.clone(),
                            TypeVariable::Unknown {
                                id: type_parameter_variables[i],
                            },
                        );
                    }
                    // TODO deal with higher kinded type variables here.
                    let mut higher_kinded_ids = HashMap::new();

                    for (field_name, field_expr) in fields.fields {
                        let (result, inner_messages) = generate_constraints(
                            source_file,
                            project_index,
                            visible_names,
                            args,
                            lambda_variables.clone(),
                            let_variables.clone(),
                            field_expr,
                        )
                        .destructure();
                        messages.extend(inner_messages);
                        if let Some(result) = result {
                            let_variables = result.let_variables;
                            type_variable_definition_ranges
                                .extend(result.type_variable_definition_ranges);
                            assumptions = assumptions.union(result.assumptions);
                            constraints = constraints.union(result.constraints);

                            // TODO this crashes if the field's type could not ben deduced! We should deny before this step.
                            // Add the constraint that the field has the required type.
                            let (_, field_type) = type_ctor
                                .fields
                                .iter()
                                .find(|(name, _)| name.name == field_name.name)
                                .expect("could not find named field");

                            // Convert the field type to a type variable, replacing type parameters like `T` with their variables assigned previously.
                            let field_type_variable =
                                instantiate_with(&field_type, &mut ids, &mut higher_kinded_ids);

                            constraints.0.push((
                                result.expr.type_variable.clone(),
                                Constraint::Equality {
                                    ty: field_type_variable,
                                    reason: ConstraintEqualityReason::Field {
                                        expr: result.expr.range(),
                                        data_type: type_constructor_invocation.data_type.clone(),
                                        type_ctor: type_constructor_invocation
                                            .data_type
                                            .name
                                            .clone(),
                                        field: field_name.name.clone(),
                                    },
                                },
                            ));

                            fields_with_constraints.push((field_name, result.expr));
                        }
                    }
                    for auto_field in fields.auto_fields {
                        // Generate a dummy expression that just has the auto_field name.
                        // This expression becomes the value of the field.
                        let field_expr = ExprPatP::Variable(IdentifierP {
                            segments: vec![auto_field.clone()],
                        });
                        let (result, inner_messages) = generate_constraints(
                            source_file,
                            project_index,
                            visible_names,
                            args,
                            lambda_variables.clone(),
                            let_variables.clone(),
                            field_expr,
                        )
                        .destructure();
                        messages.extend(inner_messages);
                        if let Some(result) = result {
                            let_variables = result.let_variables;
                            type_variable_definition_ranges
                                .extend(result.type_variable_definition_ranges);
                            assumptions = assumptions.union(result.assumptions);
                            constraints = constraints.union(result.constraints);

                            // Add the constraint that the field has the required type.
                            let (_, field_type) = type_ctor
                                .fields
                                .iter()
                                .find(|(name, _)| name.name == auto_field.name)
                                .expect("could not find named field");

                            // Convert the field type to a type variable, replacing type parameters like `T` with their variables assigned previously.
                            let field_type_variable =
                                instantiate_with(&field_type, &mut ids, &mut higher_kinded_ids);

                            constraints.0.push((
                                result.expr.type_variable.clone(),
                                Constraint::Equality {
                                    ty: field_type_variable,
                                    reason: ConstraintEqualityReason::Field {
                                        expr: result.expr.range(),
                                        data_type: type_constructor_invocation.data_type.clone(),
                                        type_ctor: type_constructor_invocation
                                            .data_type
                                            .name
                                            .clone(),
                                        field: auto_field.name.clone(),
                                    },
                                },
                            ));

                            fields_with_constraints.push((auto_field, result.expr));
                        }
                    }

                    DiagnosticResult::ok_with_many(
                        ExprTypeCheck {
                            expr: ExpressionT {
                                type_variable,
                                contents: ExpressionContentsT::ConstructData {
                                    data_type_name: type_constructor_invocation.data_type,
                                    variant: type_constructor_invocation.variant,
                                    fields: fields_with_constraints,
                                    open_brace,
                                    close_brace,
                                },
                            },
                            type_variable_definition_ranges,
                            assumptions,
                            constraints,
                            let_variables,
                            new_variables: None,
                        },
                        messages,
                    )
                },
            )
        }
        ExprPatP::Borrow { borrow_token, expr } => generate_constraints(
            source_file,
            project_index,
            visible_names,
            args,
            lambda_variables,
            let_variables,
            *expr,
        )
        .map(|mut expr| {
            let type_variable = TypeVariable::Unknown {
                id: TypeVariableId::default(),
            };
            let expr_range = expr.expr.range();
            expr.constraints.0.push((
                type_variable.clone(),
                Constraint::Equality {
                    ty: TypeVariable::Borrow {
                        ty: Box::new(expr.expr.type_variable.clone()),
                    },
                    reason: ConstraintEqualityReason::Borrow {
                        expr: expr_range,
                        borrow_token,
                    },
                },
            ));
            expr.expr = ExpressionT {
                type_variable,
                contents: ExpressionContentsT::Borrow {
                    borrow_token,
                    expr: Box::new(expr.expr),
                },
            };
            expr
        }),
        ExprPatP::Copy { copy_token, expr } => generate_constraints(
            source_file,
            project_index,
            visible_names,
            args,
            lambda_variables,
            let_variables,
            *expr,
        )
        .map(|mut expr| {
            let type_variable = TypeVariable::Unknown {
                id: TypeVariableId::default(),
            };
            let expr_range = expr.expr.range();
            expr.constraints.0.push((
                expr.expr.type_variable.clone(),
                Constraint::Equality {
                    ty: TypeVariable::Borrow {
                        ty: Box::new(type_variable.clone()),
                    },
                    reason: ConstraintEqualityReason::Copy {
                        expr: expr_range,
                        copy_token,
                    },
                },
            ));
            expr.expr = ExpressionT {
                type_variable,
                contents: ExpressionContentsT::Copy {
                    copy_token,
                    expr: Box::new(expr.expr),
                },
            };
            expr
        }),
    }
}

/// Returns an error message saying a variable was already defined.
fn already_defined(
    source_file: &SourceFileIdentifier,
    range: Range,
    previous_range: Range,
) -> ErrorMessage {
    ErrorMessage::new_with(
        String::from("a variable with this name was already defined"),
        Severity::Error,
        Diagnostic::at(source_file, &range),
        HelpMessage {
            message: String::from("previously defined here"),
            help_type: HelpType::Note,
            diagnostic: Diagnostic::at(source_file, &previous_range),
        },
    )
}

/// Deduces the type of an expression.
/// Any error messages are added to the diagnostic result.
///
/// This mostly implements the algorithm from Generalizing Hindley-Milner Type Inference Algorithms (2002)
/// <https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.9348>.
fn solve_type_constraints(
    source_file: &SourceFileIdentifier,
    project_index: &ProjectIndex,
    expr: ExpressionT,
    constraints: Constraints,
) -> DiagnosticResult<Expression> {
    // println!("Deducing type of {:#?}", expr);
    // println!("Constraints: {:#?}", constraints);

    // We implement the `SOLVE` algorithm from the above paper.
    // The substitutions are defined to be idempotent, so a map instead of an ordered vec shall suffice.

    let mut high_priority_constraints = VecDeque::new();
    let mut mid_priority_constraints = VecDeque::new();
    let mut low_priority_constraints = VecDeque::new();
    for constraint in constraints.0 {
        match &constraint.1 {
            Constraint::Equality { reason, .. } => match reason {
                ConstraintEqualityReason::LambdaType { .. } => {
                    high_priority_constraints.push_back(constraint)
                }
                ConstraintEqualityReason::ByDefinition { .. } => {
                    low_priority_constraints.push_back(constraint)
                }
                _ => mid_priority_constraints.push_back(constraint),
            },
        }
    }
    // To solve the constraints, we will pop entries off the front of the queue, process them, and if needed push them to the back of the queue.
    // There are a few phases to solving constraints - there are a number of constraints we want to process either first or last.
    // We'll start by supplying the empty substitution.
    solve_type_constraint_queue(
        source_file,
        project_index,
        high_priority_constraints,
        HashMap::<TypeVariableId, TypeVariable>::new(),
    )
    .bind(|substitution| {
        solve_type_constraint_queue(
            source_file,
            project_index,
            mid_priority_constraints,
            substitution,
        )
    })
    .bind(|substitution| {
        solve_type_constraint_queue(
            source_file,
            project_index,
            low_priority_constraints,
            substitution,
        )
    })
    .bind(|substitution| {
        // println!("Sub was:");
        // println!("{:#?}", substitution);
        substitute(&substitution, expr, source_file)
    })
}

fn solve_type_constraint_queue(
    source_file: &SourceFileIdentifier,
    project_index: &ProjectIndex,
    mut constraint_queue: VecDeque<(TypeVariable, Constraint)>,
    mut substitution: HashMap<TypeVariableId, TypeVariable>,
) -> DiagnosticResult<HashMap<TypeVariableId, TypeVariable>> {
    //dbg!(&constraint_queue);
    while let Some((type_variable, constraint)) = constraint_queue.pop_front() {
        // println!(
        //     "Solving constraint {:#?} => {:#?}",
        //     type_variable, constraint
        // );
        match constraint {
            Constraint::Equality { ty: other, reason } => {
                // This constraint specifies that `type_variable === other`.
                // So we'll find the most general unifier between the two types.
                match most_general_unifier(project_index, other.clone(), type_variable.clone()) {
                    Ok(mgu) => {
                        // Add this substitution to the list of substitutions,
                        // and also apply the substitution to the current list of constraints.
                        apply_substitution_to_constraints(&mgu, &mut constraint_queue);
                        match unify(project_index, substitution.clone(), mgu) {
                            Ok(sub) => {
                                substitution = sub;

                                // Check to make sure we haven't introduced an infinite type.
                                if let Err(error) = fix_infinite_type(&mut substitution) {
                                    return DiagnosticResult::fail(process_infinite_type_error(
                                        source_file,
                                        error,
                                        reason,
                                        substitution,
                                    ));
                                }
                            }
                            Err(error) => {
                                return DiagnosticResult::fail(process_unification_error(
                                    source_file,
                                    error,
                                    reason,
                                    substitution,
                                ));
                            }
                        }
                    }
                    Err(error) => {
                        return DiagnosticResult::fail(process_unification_error(
                            source_file,
                            error,
                            reason,
                            substitution,
                        ));
                    }
                }
            }
        }
    }

    DiagnosticResult::ok(substitution)
}

struct InfiniteTypeError {
    erroneous_substitutions: Vec<(TypeVariableId, TypeVariable)>,
}

/// Check to see if we've created an infinite type e.g. a ~ [a]. This is invariably an error.
/// If an infinite type was found, the substitution referencing it is removed from the substitution,
/// so that error messages do not stack overflow trying to print the infinite type.
fn fix_infinite_type(
    substitution: &mut HashMap<TypeVariableId, TypeVariable>,
) -> Result<(), InfiniteTypeError> {
    let mut to_remove = Vec::new();
    for (k, v) in substitution.iter() {
        if contains_id(v, k) {
            to_remove.push(*k);
        }
    }
    let erroneous_substitutions = to_remove
        .iter()
        .map(|k| substitution.remove_entry(k).unwrap())
        .filter(|(substitution_id, substitution_replacement)| {
            // Check if the constraint simply maps a type to itself.
            // This is a valid deduction, but must be removed since it results in an infinite loop.
            if let TypeVariable::Unknown {
                id: substitution_replacement_id,
            } = substitution_replacement
            {
                substitution_replacement_id != substitution_id
            } else {
                true
            }
        })
        .collect::<Vec<_>>();

    if erroneous_substitutions.is_empty() {
        Ok(())
    } else {
        Err(InfiniteTypeError {
            erroneous_substitutions,
        })
    }
}

/// Does the given type variable reference the given ID?
fn contains_id(v: &TypeVariable, id: &TypeVariableId) -> bool {
    match v {
        TypeVariable::Named { parameters, .. } => parameters.iter().any(|p| contains_id(p, id)),
        TypeVariable::Function(l, r) => contains_id(&l, id) || contains_id(&r, id),
        TypeVariable::Variable { parameters, .. } => parameters.iter().any(|v| contains_id(v, id)),
        TypeVariable::Unknown { id: other_id } => other_id == id,
        TypeVariable::Primitive(_) => false,
        TypeVariable::Borrow { ty, .. } => contains_id(&*ty, id),
    }
}

/// Returns the range that we should raise the error at, and a list of help/note messages relating to the exact constraint that was violated.
fn process_constraint_reason(
    source_file: &SourceFileIdentifier,
    ty_printer: &mut TypeVariablePrinter,
    reason: ConstraintEqualityReason,
) -> (Range, Vec<HelpMessage>) {
    // TODO make these error messages. It'll be better to make the messages
    // once we know what kinds of scenarios trigger them after we experiment more.
    match reason {
        ConstraintEqualityReason::Apply {
            function_range,
            function_ty,
            argument_range,
            argument_ty,
        } => {
            let messages = vec![
                HelpMessage {
                    message: format!(
                        "error was raised because we tried to apply this function of type {}...",
                        ty_printer.print(function_ty),
                    ),
                    help_type: HelpType::Note,
                    diagnostic: Diagnostic::at(source_file, &function_range),
                },
                HelpMessage {
                    message: format!(
                        "...to an argument of type {}",
                        ty_printer.print(argument_ty)
                    ),
                    help_type: HelpType::Note,
                    diagnostic: Diagnostic::at(source_file, &argument_range),
                },
            ];
            (function_range, messages)
        }
        ConstraintEqualityReason::ByDefinition { expr, definition } => {
            let messages = vec![HelpMessage {
                message: String::from(
                    "error was raised because this expression's type was defined here",
                ),
                help_type: HelpType::Note,
                diagnostic: Diagnostic::at(source_file, &definition),
            }];
            (expr, messages)
        }
        ConstraintEqualityReason::LambdaParameter {
            lambda,
            param_name,
            param_range,
        } => {
            let messages = vec![HelpMessage {
                message: format!(
                    "error was raised because of the use of the lambda parameter {} inside the body of the lambda expression",
                    param_name,
                ),
                help_type: HelpType::Note,
                diagnostic: Diagnostic::at(source_file, &param_range),
            }];
            (lambda, messages)
        }
        ConstraintEqualityReason::InstanceLet {
            variable_name,
            variable_type,
            expr,
            let_token,
        } => {
            let messages = vec![HelpMessage {
                message: format!(
                    "error was raised because of the use of the variable {} which has type {}",
                    variable_name,
                    ty_printer.print(variable_type)
                ),
                help_type: HelpType::Note,
                diagnostic: Diagnostic::at(source_file, &let_token),
            }];
            (expr, messages)
        }
        ConstraintEqualityReason::Field {
            expr,
            data_type,
            field,
            ..
        } => {
            let messages = vec![HelpMessage {
                message: format!(
                    "error was raised because of the use of this expression in field {} of data type {}",
                    field,
                    data_type,
                ),
                help_type: HelpType::Note,
                diagnostic: Diagnostic::at(source_file, &expr),
            }];
            (expr, messages)
        }
        _ => {
            panic!("Could not print error message reason {:#?}", reason);
        }
    }
}

fn process_infinite_type_error(
    source_file: &SourceFileIdentifier,
    error: InfiniteTypeError,
    reason: ConstraintEqualityReason,
    substitution: HashMap<TypeVariableId, TypeVariable>,
) -> ErrorMessage {
    let mut ty_printer = TypeVariablePrinter::new(substitution);

    let (error_range, help) = process_constraint_reason(source_file, &mut ty_printer, reason);

    ErrorMessage::new_with_many(
        format!(
            "a self-referential type {} ~ {} was created",
            ty_printer.print(TypeVariable::Unknown {
                id: error.erroneous_substitutions[0].0,
            }),
            ty_printer.print(error.erroneous_substitutions[0].1.clone()),
        ),
        Severity::Error,
        Diagnostic::at(source_file, &error_range),
        help,
    )
}

/// Process an error message generated by computing the most general unifier for two types.
fn process_unification_error(
    source_file: &SourceFileIdentifier,
    error: UnificationError,
    reason: ConstraintEqualityReason,
    substitution: HashMap<TypeVariableId, TypeVariable>,
) -> ErrorMessage {
    let mut ty_printer = TypeVariablePrinter::new(substitution);

    // The constraint reasons we made earlier will help us emit an error.
    let (error_range, help) = process_constraint_reason(source_file, &mut ty_printer, reason);

    // Now emit the error.
    match error {
        UnificationError::VariableNameMismatch { name, other_name } => ErrorMessage::new_with_many(
            format!("type variables {} and {} did not match", name, other_name,),
            Severity::Error,
            Diagnostic::at(source_file, &error_range),
            help,
        ),
        UnificationError::ExpectedDifferent { expected, actual } => ErrorMessage::new_with_many(
            format!(
                "expected type {}, but found type {}",
                ty_printer.print(expected),
                ty_printer.print(actual)
            ),
            Severity::Error,
            Diagnostic::at(source_file, &error_range),
            help,
        ),
        UnificationError::ExpectedVariable { actual, variable } => ErrorMessage::new_with_many(
            format!(
                "a data type {} was found, but it was expected to be the type variable {}",
                ty_printer.print(actual),
                variable,
            ),
            Severity::Error,
            Diagnostic::at(source_file, &error_range),
            help,
        ),
    }
}

fn apply_substitution_to_constraints(
    mgu: &HashMap<TypeVariableId, TypeVariable>,
    constraint_queue: &mut VecDeque<(TypeVariable, Constraint)>,
) {
    for (ty, constraint) in constraint_queue {
        apply_substitution(mgu, ty);
        match constraint {
            Constraint::Equality { ty: other, .. } => apply_substitution(mgu, other),
        }
    }
}

fn apply_substitution(sub: &HashMap<TypeVariableId, TypeVariable>, ty: &mut TypeVariable) {
    if let TypeVariable::Unknown { id } = ty {
        if let Some(sub_value) = sub.get(id) {
            *ty = sub_value.clone();
        }
    }
}

enum UnificationError {
    /// We expected a certain type, but we actually got a different type.
    ExpectedDifferent {
        expected: TypeVariable,
        actual: TypeVariable,
    },
    /// An expression was found to be of the type of two distinct variables.
    VariableNameMismatch { name: String, other_name: String },
    /// One type was a named data type, the other type was a type variable quantified in the function signature.
    ExpectedVariable {
        actual: TypeVariable,
        variable: String,
    },
}

/// Returns a substitution which unifies the two types. If one could not be found, this is a type error, and None will be returned.
fn most_general_unifier(
    project_index: &ProjectIndex,
    expected: TypeVariable,
    actual: TypeVariable,
) -> Result<HashMap<TypeVariableId, TypeVariable>, UnificationError> {
    // If one of them is an unknown type variable, just set it to the other one.
    match expected {
        TypeVariable::Named {
            name: left_name,
            parameters: left_parameters,
        } => {
            match actual {
                TypeVariable::Named {
                    name: right_name,
                    parameters: right_parameters,
                } => {
                    // Both type variables are named types.
                    // Check that they are the same.
                    if left_name == right_name {
                        // Unify the type parameters.
                        // The lists must have equal length, since the names matched.
                        let mut mgu = HashMap::new();
                        for (left_param, right_param) in
                            left_parameters.into_iter().zip(right_parameters)
                        {
                            let inner_mgu =
                                most_general_unifier(project_index, left_param, right_param)?;
                            mgu = unify(project_index, mgu, inner_mgu)?;
                        }
                        Ok(mgu)
                    } else {
                        Err(UnificationError::ExpectedDifferent {
                            expected: TypeVariable::Named {
                                name: left_name,
                                parameters: left_parameters,
                            },
                            actual: TypeVariable::Named {
                                name: right_name,
                                parameters: right_parameters,
                            },
                        })
                    }
                }
                TypeVariable::Unknown { id: right } => {
                    let mut map = HashMap::new();
                    map.insert(
                        right,
                        TypeVariable::Named {
                            name: left_name,
                            parameters: left_parameters,
                        },
                    );
                    Ok(map)
                }
                TypeVariable::Function(right_param, right_result) => {
                    Err(UnificationError::ExpectedDifferent {
                        expected: TypeVariable::Named {
                            name: left_name,
                            parameters: left_parameters,
                        },
                        actual: TypeVariable::Function(right_param, right_result),
                    })
                }
                TypeVariable::Variable { variable, .. } => {
                    Err(UnificationError::ExpectedVariable {
                        actual: TypeVariable::Named {
                            name: left_name,
                            parameters: left_parameters,
                        },
                        variable,
                    })
                }
                actual => Err(UnificationError::ExpectedDifferent {
                    expected: TypeVariable::Named {
                        name: left_name,
                        parameters: left_parameters,
                    },
                    actual,
                }),
            }
        }
        TypeVariable::Unknown { id } => {
            let mut map = HashMap::new();
            map.insert(id, actual);
            Ok(map)
        }
        TypeVariable::Function(left_param, left_result) => {
            match actual {
                TypeVariable::Function(right_param, right_result) => {
                    // Both were functions. Unify both the parameters and the results.
                    let mgu1 = most_general_unifier(project_index, *left_param, *right_param)?;
                    let mgu2 = most_general_unifier(project_index, *left_result, *right_result)?;
                    unify(project_index, mgu1, mgu2)
                }
                TypeVariable::Unknown { id: right } => {
                    let mut map = HashMap::new();
                    map.insert(right, TypeVariable::Function(left_param, left_result));
                    Ok(map)
                }
                TypeVariable::Variable { variable, .. } => {
                    Err(UnificationError::ExpectedVariable {
                        actual: TypeVariable::Function(left_param, left_result),
                        variable,
                    })
                }
                actual => Err(UnificationError::ExpectedDifferent {
                    expected: TypeVariable::Function(left_param, left_result),
                    actual,
                }),
            }
        }
        TypeVariable::Variable {
            variable,
            parameters: left_parameters,
        } => match actual {
            TypeVariable::Variable {
                variable: other_variable,
                ..
            } => {
                if other_variable == variable {
                    Ok(HashMap::new())
                } else {
                    Err(UnificationError::VariableNameMismatch {
                        name: variable,
                        other_name: other_variable,
                    })
                }
            }
            TypeVariable::Unknown { id: right } => {
                let mut map = HashMap::new();
                map.insert(
                    right,
                    TypeVariable::Variable {
                        variable,
                        parameters: left_parameters,
                    },
                );
                Ok(map)
            }
            actual => Err(UnificationError::ExpectedVariable { actual, variable }),
        },
        TypeVariable::Primitive(prim) => match actual {
            TypeVariable::Unknown { id } => {
                let mut map = HashMap::new();
                map.insert(id, TypeVariable::Primitive(prim));
                Ok(map)
            }
            TypeVariable::Primitive(actual) => {
                if prim == actual {
                    Ok(HashMap::new())
                } else {
                    Err(UnificationError::ExpectedDifferent {
                        expected: TypeVariable::Primitive(prim),
                        actual: TypeVariable::Primitive(actual),
                    })
                }
            }
            actual => Err(UnificationError::ExpectedDifferent {
                expected: TypeVariable::Primitive(prim),
                actual,
            }),
        },
        TypeVariable::Borrow { ty } => match actual {
            TypeVariable::Unknown { id } => {
                let mut map = HashMap::new();
                map.insert(id, TypeVariable::Borrow { ty });
                Ok(map)
            }
            TypeVariable::Borrow { ty: other_ty } => {
                most_general_unifier(project_index, *ty, *other_ty)
            }
            actual => Err(UnificationError::ExpectedDifferent {
                expected: TypeVariable::Borrow { ty },
                actual,
            }),
        },
    }
}

fn unify(
    project_index: &ProjectIndex,
    mut a: HashMap<TypeVariableId, TypeVariable>,
    b: HashMap<TypeVariableId, TypeVariable>,
) -> Result<HashMap<TypeVariableId, TypeVariable>, UnificationError> {
    for (id, v) in b {
        match a.entry(id) {
            Entry::Occupied(occupied) => {
                let inner_mgu = most_general_unifier(project_index, v, occupied.get().clone())?;
                a = unify(project_index, a, inner_mgu)?;
            }
            Entry::Vacant(vacant) => {
                vacant.insert(v);
            }
        }
    }
    Ok(a)
}

/// Apply the given type variable substitution to this expression.
/// This should replace all unknown types with known types, if the type check succeeded.
fn substitute(
    substitution: &HashMap<TypeVariableId, TypeVariable>,
    expr: ExpressionT,
    source_file: &SourceFileIdentifier,
) -> DiagnosticResult<Expression> {
    let range = expr.range();
    let ExpressionT {
        type_variable,
        contents,
    } = expr;

    let (ty, mut messages) =
        substitute_type(substitution, type_variable.clone(), source_file, range).destructure();

    // We only want to generate one error message, all the others will just say "could not deduce type of expression".
    messages.truncate(1);
    if let Some(message) = messages.get_mut(0) {
        if message.help.is_empty() {
            let mut tvp = TypeVariablePrinter::new(substitution.clone());
            message.help.push(HelpMessage {
                message: format!(
                    "best guess of expression type was {}",
                    tvp.print(type_variable)
                ),
                help_type: HelpType::Note,
                diagnostic: Diagnostic::at(source_file, &range),
            })
        }
    }

    match ty {
        Some(ty) => substitute_contents(substitution, contents, source_file)
            .bind(|contents| DiagnosticResult::ok_with_many(Expression { ty, contents }, messages)),
        None => DiagnosticResult::fail_many(messages),
    }
}

fn substitute_contents(
    substitution: &HashMap<TypeVariableId, TypeVariable>,
    contents: ExpressionContentsT,
    source_file: &SourceFileIdentifier,
) -> DiagnosticResult<ExpressionContents> {
    match contents {
        ExpressionContentsT::Argument(a) => DiagnosticResult::ok(ExpressionContents::Argument(a)),
        ExpressionContentsT::Local(a) => DiagnosticResult::ok(ExpressionContents::Local(a)),
        ExpressionContentsT::Symbol {
            name,
            range,
            type_variables,
        } => {
            // Check that all the type variables for this symbol are known.
            let type_variables = type_variables
                .iter()
                .map(|(ty_name, ty_id)| {
                    let (ty, messages) =
                        substitute_type(substitution, ty_id.clone(), source_file, range)
                            .destructure();
                    // The error message, if present, needs to be customised to state that the problem is with the type variable.
                    if let Some(ty) = ty {
                        DiagnosticResult::ok_with_many(ty, messages)
                    } else {
                        DiagnosticResult::fail(ErrorMessage::new(
                            format!(
                                "type variable {} from {} could not be deduced",
                                ty_name, name
                            ),
                            Severity::Error,
                            Diagnostic::at(source_file, &range),
                        ))
                    }
                })
                .collect::<DiagnosticResult<Vec<Type>>>();
            type_variables.map(|type_variables| ExpressionContents::Symbol {
                name,
                range,
                type_variables,
            })
        }
        ExpressionContentsT::Apply(l, r) => substitute(substitution, *l, source_file).bind(|l| {
            substitute(substitution, *r, source_file)
                .map(|r| ExpressionContents::Apply(Box::new(l), Box::new(r)))
        }),
        ExpressionContentsT::Lambda {
            lambda_token,
            params,
            expr,
        } => substitute(substitution, *expr, source_file).map(|expr| ExpressionContents::Lambda {
            lambda_token,
            params,
            expr: Box::new(expr),
        }),
        ExpressionContentsT::Let {
            let_token,
            name,
            expr,
        } => substitute(substitution, *expr, source_file).map(|expr| ExpressionContents::Let {
            let_token,
            name,
            expr: Box::new(expr),
        }),
        ExpressionContentsT::Block {
            open_bracket,
            close_bracket,
            statements,
        } => statements
            .into_iter()
            .map(|stmt| substitute(substitution, stmt, source_file))
            .collect::<DiagnosticResult<_>>()
            .map(|statements| ExpressionContents::Block {
                open_bracket,
                close_bracket,
                statements,
            }),
        ExpressionContentsT::ConstructData {
            data_type_name,
            variant,
            fields,
            open_brace,
            close_brace,
        } => fields
            .into_iter()
            .map(|(field_name, field_expr)| {
                substitute(substitution, field_expr, source_file)
                    .map(|field_expr| (field_name, field_expr))
            })
            .collect::<DiagnosticResult<_>>()
            .map(|fields| ExpressionContents::ConstructData {
                data_type_name,
                variant,
                fields,
                open_brace,
                close_brace,
            }),
        ExpressionContentsT::ConstantValue { value, range } => {
            DiagnosticResult::ok(ExpressionContents::ConstantValue { value, range })
        }
        ExpressionContentsT::Borrow { borrow_token, expr } => {
            substitute(substitution, *expr, source_file).map(|expr| ExpressionContents::Borrow {
                borrow_token,
                expr: Box::new(expr),
            })
        }
        ExpressionContentsT::Copy { copy_token, expr } => {
            substitute(substitution, *expr, source_file).map(|expr| ExpressionContents::Copy {
                copy_token,
                expr: Box::new(expr),
            })
        }
    }
}

fn substitute_type(
    substitution: &HashMap<TypeVariableId, TypeVariable>,
    ty: TypeVariable,
    source_file: &SourceFileIdentifier,
    range: Range,
) -> DiagnosticResult<Type> {
    match ty {
        TypeVariable::Named { name, parameters } => {
            let parameters = parameters
                .into_iter()
                .map(|param| substitute_type(substitution, param, source_file, range))
                .collect::<DiagnosticResult<Vec<_>>>();
            parameters.map(|parameters| Type::Named { name, parameters })
        }
        TypeVariable::Function(l, r) => {
            substitute_type(substitution, *l, source_file, range).bind(|l| {
                substitute_type(substitution, *r, source_file, range)
                    .map(|r| Type::Function(Box::new(l), Box::new(r)))
            })
        }
        TypeVariable::Unknown { id } => match substitution.get(&id) {
            Some(value) => {
                // Sometimes, we can have a substitution that substitutes some type variable for itself.
                // The substitution is idempotent, so there are no cycles.
                // So we'll check if `value == TypeVariable::Unknown(id)`.
                if let TypeVariable::Unknown { id: other_id } = value {
                    if *other_id == id {
                        return DiagnosticResult::fail(ErrorMessage::new(
                            String::from("could not deduce type of this expression"),
                            Severity::Error,
                            Diagnostic::at(source_file, &range),
                        ));
                    }
                }

                substitute_type(substitution, value.clone(), source_file, range)
            }
            None => DiagnosticResult::fail(ErrorMessage::new(
                String::from("could not deduce type of this expression"),
                Severity::Error,
                Diagnostic::at(source_file, &range),
            )),
        },
        TypeVariable::Variable {
            variable,
            parameters,
        } => parameters
            .into_iter()
            .map(|param| substitute_type(substitution, param, source_file, range))
            .collect::<DiagnosticResult<_>>()
            .map(|parameters| Type::Variable {
                variable,
                parameters,
            }),
        TypeVariable::Primitive(prim) => DiagnosticResult::ok(Type::Primitive(prim)),
        TypeVariable::Borrow { ty } => {
            substitute_type(substitution, *ty, source_file, range).map(|ty| Type::Borrow {
                ty: Box::new(ty),
                borrow: None,
            })
        }
    }
}
