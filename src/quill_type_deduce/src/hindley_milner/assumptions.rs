use std::collections::{hash_map::Entry, HashMap};

use quill_parser::identifier::NameP;

use crate::type_resolve::TypeVariableId;

/// A list of assumptions about each variable's type.
/// Assumptions are applied only to the current list of monomorphic and polymorphic variables,
/// i.e. exactly the list of variables introduced by lambda and let statements respectively.
#[derive(Debug, Default)]
pub(crate) struct Assumptions(pub HashMap<NameP, Vec<Assumption>>);

impl Assumptions {
    pub(crate) fn new_with(var: NameP, assumption: Assumption) -> Self {
        let mut map = HashMap::new();
        map.insert(var, vec![assumption]);
        Self(map)
    }

    pub(crate) fn union(mut self, other: Self) -> Self {
        for (ty, mut assumptions) in other.0 {
            match self.0.entry(ty) {
                Entry::Occupied(mut occupied) => occupied.get_mut().append(&mut assumptions),
                Entry::Vacant(vacant) => {
                    vacant.insert(assumptions);
                }
            }
        }
        self
    }
}

/// An assumption records the type variables assigned to a given local variable,
/// such as those local variables generated by `lambda` and `let` statements.
#[derive(Debug)]
pub(crate) struct Assumption(pub TypeVariableId);
