use std::collections::{btree_map::Entry, BTreeMap};

use quill_common::{
    diagnostic::{Diagnostic, DiagnosticResult, ErrorMessage, HelpMessage, HelpType, Severity},
    location::{Range, Ranged, SourceFileIdentifier},
    name::QualifiedName,
};
use quill_index::{ProjectIndex, TypeDeclarationTypeI};
use quill_parser::{
    expr_pat::{ConstantValue, ExprPatP},
    identifier::{IdentifierP, NameP},
};
use quill_type::PrimitiveType;

use crate::{
    hindley_milner::LetStatementNewVariables,
    hir::expr::{
        AbstractionVariable, BoundVariable, ExpressionContentsT, ExpressionT, TypeVariable,
    },
    index_resolve::{
        as_variable, instantiate, instantiate_with, resolve_definition, resolve_type_constructor,
        InstantiationResult,
    },
    type_check::VisibleNames,
    type_resolve::TypeVariableId,
};

use super::{
    assumptions::{Assumption, Assumptions},
    constraints::{Constraint, ConstraintEqualityReason, Constraints},
    ExprTypeCheck,
};

/// Assigns new type variables to each sub-expression, so that this expression can be easily type checked.
/// This uses the algorithm from <https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.9348> to assign constraints to these type variables.
///
/// Assumptions and constraints will be generated by each sub-expression.
/// `lambda_variables` is the set of variables that we introduced using a lambda expression. Assumptions in the returned value only relate to this
/// set of lambda variables.
/// `let_variables` is the set of variables that we introduced using a let expression.
pub(crate) fn generate_constraints(
    source_file: &SourceFileIdentifier,
    project_index: &ProjectIndex,
    visible_names: &VisibleNames,
    args: &BTreeMap<String, BoundVariable>,
    mut lambda_variables: BTreeMap<String, AbstractionVariable>,
    mut let_variables: BTreeMap<String, AbstractionVariable>,
    expr: ExprPatP,
) -> DiagnosticResult<ExprTypeCheck> {
    match expr {
        ExprPatP::Variable(identifier) => {
            // Let's try to work out what this identifier is referring to.
            if identifier.segments.len() == 1 {
                let name = identifier.segments[0].clone();
                // First, check the function's arguments.
                if let Some(arg) = args.get(&name.name) {
                    // We don't need to add an assumption or constraint about this type variable, since it is known.
                    return DiagnosticResult::ok(ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable: as_variable(&arg.var_type),
                            contents: ExpressionContentsT::Argument(name),
                        },
                        type_variable_definition_ranges: BTreeMap::new(),
                        assumptions: Assumptions::default(),
                        constraints: Constraints::default(),
                        let_variables,
                        new_variables: None,
                    });
                }

                // Now, check the lambda variables.
                if lambda_variables.get(&name.name).is_some() {
                    let type_variable = TypeVariableId::default();
                    let identifier_name = name.clone();
                    let mut type_variable_definition_ranges = BTreeMap::new();
                    type_variable_definition_ranges.insert(type_variable, name.range);
                    return DiagnosticResult::ok(ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable: TypeVariable::Unknown { id: type_variable },
                            contents: ExpressionContentsT::Local(name),
                        },
                        type_variable_definition_ranges,
                        assumptions: Assumptions::new_with(
                            identifier_name,
                            Assumption(type_variable),
                        ),
                        constraints: Constraints::default(),
                        let_variables,
                        new_variables: None,
                    });
                }
                // Now, check the let variables.
                if let_variables.get(&name.name).is_some() {
                    let type_variable = TypeVariableId::default();
                    let identifier_name = name.clone();
                    let mut type_variable_definition_ranges = BTreeMap::new();
                    type_variable_definition_ranges.insert(type_variable, name.range);
                    return DiagnosticResult::ok(ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable: TypeVariable::Unknown { id: type_variable },
                            contents: ExpressionContentsT::Local(name),
                        },
                        type_variable_definition_ranges,
                        assumptions: Assumptions::new_with(
                            identifier_name,
                            Assumption(type_variable),
                        ),
                        constraints: Constraints::default(),
                        let_variables,
                        new_variables: None,
                    });
                }
            }

            // Now let's look for a symbol in scope.
            match resolve_definition(source_file, &identifier, visible_names)
                .destructure()
                .0
            {
                Some((symbol_source_file, symbol)) => {
                    // We don't need an assumption, we know what the type of this symbol is.
                    let InstantiationResult {
                        result: type_variable,
                        ids: type_variables,
                        ..
                    } = instantiate(&symbol.symbol_type);
                    DiagnosticResult::ok(ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable,
                            contents: ExpressionContentsT::Symbol {
                                name: QualifiedName {
                                    source_file: symbol_source_file.clone(),
                                    name: symbol.name.name.clone(),
                                    range: symbol.name.range,
                                },
                                range: identifier.range(),
                                type_variables,
                            },
                        },
                        type_variable_definition_ranges: BTreeMap::new(),
                        assumptions: Assumptions::default(),
                        constraints: Constraints::default(),
                        let_variables,
                        new_variables: None,
                    })
                }
                // If None, we couldn't find a symbol in scope.
                None => {
                    // Now, check to see if this is an immediate variable like `unit`, which always produces a value.

                    DiagnosticResult::fail(ErrorMessage::new(
                        format!("variable `{}` not recognised", identifier),
                        Severity::Error,
                        Diagnostic::at(source_file, &identifier),
                    ))
                }
            }
        }
        ExprPatP::Immediate {
            range,
            value: ConstantValue::Unit,
        } => DiagnosticResult::ok(ExprTypeCheck {
            expr: ExpressionT {
                type_variable: TypeVariable::Primitive(PrimitiveType::Unit),
                contents: ExpressionContentsT::ConstantValue {
                    range,
                    value: ConstantValue::Unit,
                },
            },
            type_variable_definition_ranges: BTreeMap::new(),
            assumptions: Assumptions::default(),
            constraints: Constraints::default(),
            let_variables,
            new_variables: None,
        }),
        ExprPatP::Immediate {
            range,
            value: ConstantValue::Bool(value),
        } => DiagnosticResult::ok(ExprTypeCheck {
            expr: ExpressionT {
                type_variable: TypeVariable::Primitive(PrimitiveType::Bool),
                contents: ExpressionContentsT::ConstantValue {
                    range,
                    value: ConstantValue::Bool(value),
                },
            },
            type_variable_definition_ranges: BTreeMap::new(),
            assumptions: Assumptions::default(),
            constraints: Constraints::default(),
            let_variables,
            new_variables: None,
        }),
        ExprPatP::Immediate {
            range,
            value: ConstantValue::Int(value),
        } => DiagnosticResult::ok(ExprTypeCheck {
            expr: ExpressionT {
                type_variable: TypeVariable::Primitive(PrimitiveType::Int),
                contents: ExpressionContentsT::ConstantValue {
                    range,
                    value: ConstantValue::Int(value),
                },
            },
            type_variable_definition_ranges: BTreeMap::new(),
            assumptions: Assumptions::default(),
            constraints: Constraints::default(),
            let_variables,
            new_variables: None,
        }),
        ExprPatP::Apply(left, right) => {
            generate_constraints(
                source_file,
                project_index,
                visible_names,
                args,
                lambda_variables.clone(),
                let_variables.clone(),
                *left,
            )
            .bind(|left| {
                generate_constraints(
                    source_file,
                    project_index,
                    visible_names,
                    args,
                    lambda_variables,
                    let_variables.clone(),
                    *right,
                )
                .map(|right| {
                    let left_type = left.expr.type_variable.clone();
                    let right_type = right.expr.type_variable.clone();
                    let result_type = TypeVariable::Unknown {
                        id: TypeVariableId::default(),
                    };

                    let function_range = left.expr.contents.range();
                    let argument_range = right.expr.contents.range();
                    let function_ty = left.expr.type_variable.clone();
                    let argument_ty = right.expr.type_variable.clone();

                    // This expression was: left_type right_type : result_type
                    // Constraint: left_type === right_type -> result_type
                    let mut type_variable_definition_ranges = BTreeMap::new();
                    type_variable_definition_ranges.extend(left.type_variable_definition_ranges);
                    type_variable_definition_ranges.extend(right.type_variable_definition_ranges);
                    ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable: result_type.clone(),
                            contents: ExpressionContentsT::Apply(
                                Box::new(left.expr),
                                Box::new(right.expr),
                            ),
                        },
                        type_variable_definition_ranges,
                        assumptions: left.assumptions.union(right.assumptions),
                        constraints: left.constraints.union(right.constraints).union(
                            Constraints::new_with(
                                left_type,
                                Constraint::Equality {
                                    ty: TypeVariable::Function(
                                        Box::new(right_type),
                                        Box::new(result_type),
                                    ),
                                    reason: ConstraintEqualityReason::Apply {
                                        function_range,
                                        argument_range,
                                        function_ty,
                                        argument_ty,
                                    },
                                },
                            ),
                        ),
                        let_variables,
                        new_variables: None,
                    }
                })
            })
        }
        ExprPatP::Unknown(_) => panic!("we should not ever have an unknown in an expression"),
        ExprPatP::Lambda {
            lambda_token,
            params,
            expr,
        } => {
            // This introduces new lambda variables, so we'll need to edit the `lambda_variables` map.
            let mut messages = Vec::new();
            let mut param_types = Vec::new();
            let mut type_variable_definition_ranges = BTreeMap::new();

            for param in &params {
                let NameP { name, range, .. } = param;

                let param_type = TypeVariableId::default();
                param_types.push(param_type);
                type_variable_definition_ranges.insert(param_type, *range);

                if name == "_" {
                    // Unnamed lambda parameters do not need to be tracked by name here.
                    continue;
                }
                match lambda_variables.entry(name.clone()) {
                    Entry::Occupied(occupied) => {
                        messages.push(already_defined(source_file, *range, occupied.get().range));
                    }
                    Entry::Vacant(vacant) => {
                        if let Some(previous) = args.get(name) {
                            messages.push(already_defined(source_file, *range, previous.range));
                        }
                        if let Some(previous) = let_variables.get(name) {
                            messages.push(already_defined(source_file, *range, previous.range));
                        }
                        vacant.insert(AbstractionVariable {
                            range: *range,
                            var_type: param_type,
                        });
                    }
                }
            }

            DiagnosticResult::ok_with_many(lambda_variables, messages)
                .deny()
                .bind(|lambda_variables| {
                    generate_constraints(
                        source_file,
                        project_index,
                        visible_names,
                        args,
                        lambda_variables,
                        let_variables.clone(),
                        *expr,
                    )
                    .map(|mut expr| {
                        // First, add the constraint that this lambda abstraction's type is input_types -> expr.type.
                        // Gradually process the params to this function, curring each at a time, to get a resultant type variable.
                        let mut lambda_type = expr.expr.type_variable.clone();
                        for param in param_types.iter().rev() {
                            let lambda_step_type = TypeVariable::Unknown {
                                id: TypeVariableId::default(),
                            };
                            expr.constraints.0.push((
                                lambda_step_type.clone(),
                                Constraint::Equality {
                                    ty: TypeVariable::Function(
                                        Box::new(TypeVariable::Unknown { id: *param }),
                                        Box::new(lambda_type),
                                    ),
                                    reason: ConstraintEqualityReason::LambdaType {
                                        lambda: lambda_token,
                                    },
                                },
                            ));
                            lambda_type = lambda_step_type;
                        }

                        // Let's now remove and process the assumptions about the parameters.
                        // This expression was: lambda params -> expr : (input_types -> expr.type)
                        // Constraints: ts === input_types, for all assumptions that params : ts
                        let mut new_constraints = Vec::new();
                        for ((param, assumptions), param_type) in params
                            .iter()
                            .map(|param| {
                                (param, expr.assumptions.0.remove(param).unwrap_or_default())
                            })
                            .zip(param_types.clone())
                        {
                            for assumption in assumptions {
                                new_constraints.push((
                                    TypeVariable::Unknown { id: param_type },
                                    Constraint::Equality {
                                        ty: TypeVariable::Unknown { id: assumption.0 },
                                        reason: ConstraintEqualityReason::LambdaParameter {
                                            lambda: lambda_token,
                                            param_name: param.name.clone(),
                                            param_range: param.range,
                                        },
                                    },
                                ));
                            }
                        }
                        expr.constraints.0.extend(new_constraints);

                        type_variable_definition_ranges
                            .extend(expr.type_variable_definition_ranges);

                        ExprTypeCheck {
                            expr: ExpressionT {
                                type_variable: lambda_type,
                                contents: ExpressionContentsT::Lambda {
                                    lambda_token,
                                    params: params
                                        .into_iter()
                                        .zip(
                                            param_types
                                                .into_iter()
                                                .map(|id| TypeVariable::Unknown { id }),
                                        )
                                        .collect(),
                                    expr: Box::new(expr.expr),
                                },
                            },
                            type_variable_definition_ranges,
                            assumptions: expr.assumptions,
                            constraints: expr.constraints,
                            let_variables,
                            new_variables: None,
                        }
                    })
                })
        }
        ExprPatP::Let {
            let_token,
            name,
            expr,
        } => {
            generate_constraints(
                source_file,
                project_index,
                visible_names,
                args,
                lambda_variables.clone(),
                let_variables.clone(),
                *expr,
            )
            .bind(|expr| {
                // This introduces new let variables, so we'll need to edit the `let_variables` map.
                let mut messages = Vec::new();
                let new_variable_type = TypeVariableId::default();
                let mut type_variable_definition_ranges = BTreeMap::new();

                let NameP { name, range } = &name;
                match let_variables.entry(name.clone()) {
                    Entry::Occupied(occupied) => {
                        messages.push(already_defined(source_file, *range, occupied.get().range));
                    }
                    Entry::Vacant(vacant) => {
                        if let Some(previous) = args.get(name) {
                            messages.push(already_defined(source_file, *range, previous.range));
                        }
                        if let Some(previous) = lambda_variables.get(name) {
                            messages.push(already_defined(source_file, *range, previous.range));
                        }
                        vacant.insert(AbstractionVariable {
                            range: *range,
                            var_type: new_variable_type,
                        });
                        type_variable_definition_ranges.insert(new_variable_type, *range);
                    }
                }

                let name = NameP {
                    name: name.clone(),
                    range: *range,
                };

                let mut constraints = expr.constraints;
                constraints.0.push((
                    TypeVariable::Unknown {
                        id: new_variable_type,
                    },
                    Constraint::Equality {
                        ty: expr.expr.type_variable.clone(),
                        reason: ConstraintEqualityReason::LetType {
                            let_token,
                            expression: expr.expr.range(),
                        },
                    },
                ));

                DiagnosticResult::ok_with_many(
                    ExprTypeCheck {
                        expr: ExpressionT {
                            type_variable: TypeVariable::Primitive(PrimitiveType::Unit),
                            contents: ExpressionContentsT::Let {
                                let_token,
                                name: name.clone(),
                                expr: Box::new(expr.expr),
                            },
                        },
                        type_variable_definition_ranges,
                        assumptions: expr.assumptions,
                        constraints,
                        let_variables,
                        new_variables: Some(LetStatementNewVariables {
                            let_token,
                            new_variables: vec![(name, new_variable_type)],
                        }),
                    },
                    messages,
                )
            })
        }
        ExprPatP::Block {
            open_bracket,
            close_bracket,
            statements,
        } => {
            // Generate constraints for every statement in the block.
            let mut statements_with_constraints = Vec::new();
            let mut messages = Vec::new();
            let mut let_variables = let_variables;
            let mut type_variable_definition_ranges = BTreeMap::new();
            let mut assumptions = Assumptions::default();
            let mut constraints = Constraints::default();
            // The list of new variables is updated whenever we introduce a `let` statement in this block.
            let mut new_variables = Vec::<LetStatementNewVariables>::new();
            // println!("Statements: {:#?}", statements);
            for statement in statements {
                let (result, inner_messages) = generate_constraints(
                    source_file,
                    project_index,
                    visible_names,
                    args,
                    lambda_variables.clone(),
                    let_variables.clone(),
                    statement,
                )
                .destructure();
                messages.extend(inner_messages);
                if let Some(mut result) = result {
                    constraints = constraints.union(result.constraints);

                    for some_new_variables in &new_variables {
                        for (variable_name, variable_type_var_id) in
                            &some_new_variables.new_variables
                        {
                            // First, let's remove and store the assumptions about the variables that we created in previous let statements.
                            let let_assumptions = result
                                .assumptions
                                .0
                                .remove(variable_name)
                                .unwrap_or_else(Vec::new);

                            for assumption in let_assumptions {
                                constraints.0.push((
                                    TypeVariable::Unknown { id: assumption.0 },
                                    Constraint::Equality {
                                        ty: TypeVariable::Unknown {
                                            id: *variable_type_var_id,
                                        },
                                        reason: ConstraintEqualityReason::InstanceLet {
                                            let_token: some_new_variables.let_token,
                                            expr: result.expr.range(),
                                            variable_name: variable_name.name.to_string(),
                                            variable_type: TypeVariable::Unknown {
                                                id: *variable_type_var_id,
                                            },
                                        },
                                    },
                                ));
                            }
                        }
                    }

                    let_variables = result.let_variables;
                    type_variable_definition_ranges.extend(result.type_variable_definition_ranges);
                    assumptions = assumptions.union(result.assumptions);
                    statements_with_constraints.push(result.expr);

                    if let Some(more_new_variables) = result.new_variables {
                        new_variables.push(more_new_variables);
                    }
                }
            }

            if statements_with_constraints.is_empty() {
                // We can't deduce the block's type so we have to fail early.
                return DiagnosticResult::fail_many(messages);
            }

            // Work out what the type of the block is. Typically, this is just the type of the last statement in the block,
            // unless a final semicolon was added.
            let block_type = statements_with_constraints[statements_with_constraints.len() - 1]
                .type_variable
                .clone();

            DiagnosticResult::ok_with_many(
                ExprTypeCheck {
                    expr: ExpressionT {
                        type_variable: block_type,
                        contents: ExpressionContentsT::Block {
                            open_bracket,
                            close_bracket,
                            statements: statements_with_constraints,
                        },
                    },
                    type_variable_definition_ranges,
                    assumptions,
                    constraints,
                    let_variables,
                    new_variables: None,
                },
                messages,
            )
        }
        ExprPatP::ConstructData {
            data_constructor,
            fields,
            open_brace,
            close_brace,
        } => {
            // Resolve the type constructor that was invoked.
            resolve_type_constructor(source_file, &data_constructor, visible_names).bind(
                |type_constructor_invocation| {
                    // Generate a type variable for this data type.
                    let type_parameter_variables = (0..type_constructor_invocation.num_parameters)
                        .map(|_| TypeVariableId::default())
                        .collect::<Vec<_>>();
                    let type_variable = TypeVariable::Named {
                        name: type_constructor_invocation.data_type.clone(),
                        parameters: type_parameter_variables
                            .iter()
                            .map(|id| TypeVariable::Unknown { id: *id })
                            .collect(),
                    };

                    // Find the type constructor.
                    let (type_ctor, type_params) = match &visible_names.types
                        [type_constructor_invocation.data_type.name.as_str()]
                    .decl
                    .decl_type
                    {
                        TypeDeclarationTypeI::Data(datai) => (&datai.type_ctor, &datai.type_params),
                        TypeDeclarationTypeI::Enum(enumi) => (
                            &enumi
                                .variants
                                .iter()
                                .find(|variant| {
                                    &variant.name.name
                                        == type_constructor_invocation.variant.as_ref().unwrap()
                                })
                                .unwrap()
                                .type_ctor,
                            &enumi.type_params,
                        ),
                    };

                    let mut messages = Vec::new();

                    // Check to see if all fields have been created.
                    for (field, _field_ty) in &type_ctor.fields {
                        if fields
                            .fields
                            .iter()
                            .all(|(field_name, _)| field_name != field)
                            && fields
                                .auto_fields
                                .iter()
                                .all(|field_name| field_name != field)
                        {
                            messages.push(ErrorMessage::new(
                                format!("field `{}` is missing from this object", field),
                                Severity::Error,
                                Diagnostic::at(source_file, &data_constructor),
                            ));
                        }
                    }

                    // Generate constraints for each field.
                    let mut fields_with_constraints = Vec::new();
                    let mut type_variable_definition_ranges = BTreeMap::new();
                    let mut assumptions = Assumptions::default();
                    let mut constraints = Constraints::default();

                    let mut ids = BTreeMap::new();
                    for (i, type_param) in type_params.iter().enumerate() {
                        ids.insert(
                            type_param.name.clone(),
                            TypeVariable::Unknown {
                                id: type_parameter_variables[i],
                            },
                        );
                    }
                    // TODO deal with higher kinded type variables here.
                    let mut higher_kinded_ids = BTreeMap::new();

                    for (field_name, field_expr) in fields.fields {
                        let (result, inner_messages) = generate_constraints(
                            source_file,
                            project_index,
                            visible_names,
                            args,
                            lambda_variables.clone(),
                            let_variables.clone(),
                            field_expr,
                        )
                        .destructure();
                        messages.extend(inner_messages);
                        if let Some(result) = result {
                            let_variables = result.let_variables;
                            type_variable_definition_ranges
                                .extend(result.type_variable_definition_ranges);
                            assumptions = assumptions.union(result.assumptions);
                            constraints = constraints.union(result.constraints);

                            // TODO this crashes if the field's type could not ben deduced! We should deny before this step.
                            // Add the constraint that the field has the required type.
                            let (_, field_type) = type_ctor
                                .fields
                                .iter()
                                .find(|(name, _)| name.name == field_name.name)
                                .expect("could not find named field");

                            // Convert the field type to a type variable, replacing type parameters like `T` with their variables assigned previously.
                            let field_type_variable =
                                instantiate_with(field_type, &mut ids, &mut higher_kinded_ids);

                            constraints.0.push((
                                result.expr.type_variable.clone(),
                                Constraint::Equality {
                                    ty: field_type_variable,
                                    reason: ConstraintEqualityReason::Field {
                                        expr: result.expr.range(),
                                        data_type: type_constructor_invocation.data_type.clone(),
                                        type_ctor: type_constructor_invocation
                                            .data_type
                                            .name
                                            .clone(),
                                        field: field_name.name.clone(),
                                    },
                                },
                            ));

                            fields_with_constraints.push((field_name, result.expr));
                        }
                    }
                    for auto_field in fields.auto_fields {
                        // Generate a dummy expression that just has the auto_field name.
                        // This expression becomes the value of the field.
                        let field_expr = ExprPatP::Variable(IdentifierP {
                            segments: vec![auto_field.clone()],
                        });
                        let (result, inner_messages) = generate_constraints(
                            source_file,
                            project_index,
                            visible_names,
                            args,
                            lambda_variables.clone(),
                            let_variables.clone(),
                            field_expr,
                        )
                        .destructure();
                        messages.extend(inner_messages);
                        if let Some(result) = result {
                            let_variables = result.let_variables;
                            type_variable_definition_ranges
                                .extend(result.type_variable_definition_ranges);
                            assumptions = assumptions.union(result.assumptions);
                            constraints = constraints.union(result.constraints);

                            // Add the constraint that the field has the required type.
                            let (_, field_type) = type_ctor
                                .fields
                                .iter()
                                .find(|(name, _)| name.name == auto_field.name)
                                .expect("could not find named field");

                            // Convert the field type to a type variable, replacing type parameters like `T` with their variables assigned previously.
                            let field_type_variable =
                                instantiate_with(field_type, &mut ids, &mut higher_kinded_ids);

                            constraints.0.push((
                                result.expr.type_variable.clone(),
                                Constraint::Equality {
                                    ty: field_type_variable,
                                    reason: ConstraintEqualityReason::Field {
                                        expr: result.expr.range(),
                                        data_type: type_constructor_invocation.data_type.clone(),
                                        type_ctor: type_constructor_invocation
                                            .data_type
                                            .name
                                            .clone(),
                                        field: auto_field.name.clone(),
                                    },
                                },
                            ));

                            fields_with_constraints.push((auto_field, result.expr));
                        }
                    }

                    DiagnosticResult::ok_with_many(
                        ExprTypeCheck {
                            expr: ExpressionT {
                                type_variable,
                                contents: ExpressionContentsT::ConstructData {
                                    data_type_name: type_constructor_invocation.data_type,
                                    variant: type_constructor_invocation.variant,
                                    fields: fields_with_constraints,
                                    open_brace,
                                    close_brace,
                                },
                            },
                            type_variable_definition_ranges,
                            assumptions,
                            constraints,
                            let_variables,
                            new_variables: None,
                        },
                        messages,
                    )
                },
            )
        }
        ExprPatP::Borrow { borrow_token, expr } => generate_constraints(
            source_file,
            project_index,
            visible_names,
            args,
            lambda_variables,
            let_variables,
            *expr,
        )
        .map(|mut expr| {
            let type_variable = TypeVariable::Unknown {
                id: TypeVariableId::default(),
            };
            let expr_range = expr.expr.range();
            expr.constraints.0.push((
                type_variable.clone(),
                Constraint::Equality {
                    ty: TypeVariable::Borrow {
                        ty: Box::new(expr.expr.type_variable.clone()),
                    },
                    reason: ConstraintEqualityReason::Borrow {
                        expr: expr_range,
                        borrow_token,
                    },
                },
            ));
            expr.expr = ExpressionT {
                type_variable,
                contents: ExpressionContentsT::Borrow {
                    borrow_token,
                    expr: Box::new(expr.expr),
                },
            };
            expr
        }),
        ExprPatP::Copy { copy_token, expr } => generate_constraints(
            source_file,
            project_index,
            visible_names,
            args,
            lambda_variables,
            let_variables,
            *expr,
        )
        .map(|mut expr| {
            let type_variable = TypeVariable::Unknown {
                id: TypeVariableId::default(),
            };
            let expr_range = expr.expr.range();
            expr.constraints.0.push((
                expr.expr.type_variable.clone(),
                Constraint::Equality {
                    ty: TypeVariable::Borrow {
                        ty: Box::new(type_variable.clone()),
                    },
                    reason: ConstraintEqualityReason::Copy {
                        expr: expr_range,
                        copy_token,
                    },
                },
            ));
            expr.expr = ExpressionT {
                type_variable,
                contents: ExpressionContentsT::Copy {
                    copy_token,
                    expr: Box::new(expr.expr),
                },
            };
            expr
        }),
        ExprPatP::Impl { impl_token, body } => {
            let type_variable = TypeVariableId::default();
            DiagnosticResult::ok(ExprTypeCheck {
                expr: ExpressionT {
                    type_variable: TypeVariable::Unknown { id: type_variable },
                    contents: ExpressionContentsT::Impl {
                        impl_token,
                        implementations: body,
                    },
                },
                type_variable_definition_ranges: {
                    let mut map = BTreeMap::new();
                    map.insert(type_variable, impl_token);
                    map
                },
                assumptions: Assumptions::default(),
                constraints: Constraints::default(),
                let_variables: BTreeMap::new(),
                new_variables: None,
            })
        }
        ExprPatP::ImplPattern { .. } => unreachable!(),
    }
}

/// Returns an error message saying a variable was already defined.
fn already_defined(
    source_file: &SourceFileIdentifier,
    range: Range,
    previous_range: Range,
) -> ErrorMessage {
    ErrorMessage::new_with(
        String::from("a variable with this name was already defined"),
        Severity::Error,
        Diagnostic::at(source_file, &range),
        HelpMessage {
            message: String::from("previously defined here"),
            help_type: HelpType::Note,
            diagnostic: Diagnostic::at(source_file, &previous_range),
        },
    )
}
