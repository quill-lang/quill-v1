# Compilation Passes

The Quill compiler runs a number of passes on input code to transform it into machine code. The passes are detailed below. If any pass fails (i.e. emits an unrecoverable error), then subsequent passes are not executed, and the compiler stops processing.

## Lexing

The lexing phase is the first pass. It takes an input string of code, and converts it into a stream of individual tokens, which after that point may not be separated. It assigns each token a _type_, such as `Assign` (`=`) or `Arrow` (`->`). Then, the lexer pairs up opening and closing brackets of each type, grouping the contents of each bracketed block into a _token tree_. It then emits the list of token trees it has lexed.

## Parser

The parsing phase is the next pass. It converts a list of token trees (representing a source file) and identifies their structure. For example, it identifies top-level item declarations such as data types and definitions, and it also parses the contents of expressions.

## Index

The indexing phase collates all of the parsed files from the entire project and compiles top-level data declarations and definitions into an index. At this point, the types of definitions are deduced, but their contents are not considered. Similarly, the types of fields of data types are deduced.

This phase is split into two halves. First, the type _cache_ is created, which stores all type declarations. Then, the type cache is used to resolve the types of all definitions and fields in data types.

## Type Checking

The type checking phase uses the project index, generated by the previous step, to deduce all types of expressions inside definitions. A Hindley-Milner-style algorithm is used, with the precise implementation customised to the language. At the moment, higher-kinded types technically work, but they are not usable yet since type classes are yet to be added to the language.

This step returns the representation of the source file in HIR, the first real intermediate representation. At this point, much of the syntactic sugar in the language has been removed to help with future steps. All types of all expressions are now known, but no monormorphisation has happened, so we might still be stuck with just knowing type variables.

## Borrow Checking

The borrow checking phase computes the lifetimes of borrows, and checks that all borrows to data are valid. This step outputs MIR, a mid-level intermediate representation, where creation and destruction of objects is made explicit.

## Imperative Conversion

This phase converts the functional-style constructs (iterators, folds, recursion, immutability) into imperative constructs (loops, reassignment). This step tries to optimise certain kinds of recursion into simple loops. This outputs LIR, the low level intermediate representation, that is essentially a control flow graph.

## LLVM IR

Finally, we can produce LLVM IR, an IR which can be translated into an object file for many kinds of architectures.

## Linking

We invoke `cmake` to call upon a linker to combine the object files into a single executable, and to link statically with the C standard library. This allows us to use common, optimised functions such as `malloc`.
