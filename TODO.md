- Make `ProjectTypes` a real struct so that we can abstract away the code to retrieve a named type or definition.
- Make it a hard error to use a `let` statement outside a block. This can mess with move checking and it's basically a useless feature anyway since it returns the unit type.
- Make a proper `main` entry point function.
- When destructuring an object, drop all fields that we don't care about.
- Make a proper `else` block for the `SwitchDiscriminant` LLVM IR.
- Add an assert that the `ctx.func.func.source_file` comes from a specific "intrinsics" module inside LLVM IR creation of compiler intrinsics.
- Decide what terms to use for high level constructs: project, package, module, crate, binary...?
- Implement a proper vtable for function objects and dynamic trait objects. Should dynamic trait objects be limited to single dispatch?
- The heap allocation algorithm might stack overflow with large projects with lots of indirection. Convert recursion into a loop.
- Maybe add a keyword to hint to the compiler that we want heap allocation on a specific variable.
- Convert `LLVMStructRepresentation` to a specialised `AnyTypeRepresentation` to avoid code duplication.
- If the `quillc` build fails, don't run the executable anyway.
- You can currently create objects without all required fields.
- Refactor large files.
- Implement pattern exhaustiveness check *in MIR*.
- Try using symbol names `+, -` etc in weird places e.g. type parameters, to see what breaks.
- Remove brackets around definitions (and the `def` keyword) to make it more like other functional languages.
