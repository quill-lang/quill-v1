initSidebarItems({"enum":[["DefinitionBodyM",""],["KnownValue","A value that we know at compile time. Useful for inlining."],["LocalVariableName","A local variable is a value which can be operated on by functions and expressions. Other objects, such as symbols in global scope, must be instanced as local variables before being operated on. This allows the borrow checker and the code translator to better understand the control flow and data flow."],["PlaceSegment",""],["Rvalue","Represents the use of a value that we can feed into an expression or function. We can only read from (not write to) an rvalue."],["StatementKind","In MIR, the program is in static single assignment form: each variable is assigned once only. A variable called `target` is typically where we store the result of a statement."],["TerminatorKind",""]],"struct":[["ArgumentIndex",""],["BasicBlock","A basic block is a block of code that can be executed, and may manipulate values. Control flow is entirely linear inside a basic block. After this basic block, we may branch to one of several places."],["BasicBlockId",""],["ControlFlowGraph","After validation, the control flow graph must be in a topologically sorted order: we jump only from lower-indexed basic blocks to higher-indexed basic blocks. This means that, to trace control flow, ensuring that each variable is initialised before used, you can just iterate in order over the list of basic blocks."],["DefinitionInfo",""],["DefinitionM","A definition for a symbol, i.e. a function or constant. The functionâ€™s type is `arg_types -> return_type`. For example, if we defined a function"],["GenerationResult",""],["LocalVariableDetails",""],["LocalVariableId",""],["LocalVariableInfo","Information about a local variable, either explicitly or implicitly defined."],["Place","A place in memory that we can read from and write to."],["Statement",""],["Terminator",""]]});